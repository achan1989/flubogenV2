// Protobrain V2 for RP2040

// OSD chip might not work if powered by long/shitty USB cable, requires 5V
// On startup all GPIOs are in hi-z with a pull-down

// The WS2812 outputs are generated by the PWM peripherals (the duty cycle codes the bits) all timed to run with a 1.2us period at 120ns resolution
// PWM wrap IRQ is too slow to properly update the duty cycle value, causes bit repeats
// Instead DMA is used (DREQ on PWM wrap) to load the values from a duty cycle buffer
// The buffer has a last value set to 0 to force the output low once the buffer has been sent out (WS2812 reset period)
// FACE:	GPIO12	PWM6A	PWMBufferFaceCheek
// CHEEK:	GPIO13	PWM6B
// BODY0:	GPIO14	PWM7A	PWMBufferBody0Body1
// BODY1:	GPIO15	PWM7B
// Each PWM slice has two channels (A and B). Warning: register names use "CHx" 0 to 7 to actually names slices, which sucks.
// The counter compare (duty cycle) registers group both channels so they can only be updated at the same time, which also sucks. The pwm_set_chan_level() gets around that with a read-modify-write to only update part of the register.
// DMA can't do that however, so the DMA buffer must be made of uint32 containing two uint16, one for each channel of the slice, like the register expects.

// SD card used in SDIO mode, uses PIO0

// TODO: Current sense, auto brightness scale down if above max current
// TOOD: Interactive console to set values, save/load to txt file

// NOTE: The old MAX7456 driver assumes that the chip was loaded with a modified charset to match the standard ASCII table,
// this won't work with a brand new MAX7456.

// ADC values for automatic brightness adjustment (GL5528 photoresistor + 10k pulldown)

#include <stdlib.h>
#include "main.h"
#include "gpio.h"
#include "osd.h"
#include "pico/stdlib.h"
#include "sd_card.h"
#include "ff.h"
#include "leds.h"
#include "f_util.h"
#include "pico/time.h"
// TODO: Replace these with actual animations
#define COLOR_CHEEK 0x0000FF	// BBGGRR
#define COLOR_BODY0 0xFFFF00	// BBGGRR
#define COLOR_BODY1 0x00FFFF	// BBGGRR

#define RANDOM_ANIMATION_PERIOD 5000  // in ms

bool debugOutput = true;	// Debug print toggle

rgbColor24bpp_t colorBufferFace[FACE_LED_STRIP_LENGTH];
rgbColor24bpp_t colorBufferCheek[CHEEK_LED_STRIP_LENGTH];
rgbColor24bpp_t colorBufferBody0[BODY0_LED_STRIP_LENGTH];
rgbColor24bpp_t colorBufferBody1[BODY1_LED_STRIP_LENGTH];

uint32_t PWMBufferFaceCheek[LED_DATA_SIZE(MAX_LEDS_PER_OUTPUT)];	// One uint32_t value for both PWM channels of same slice, represents one WS2812 bit each
uint32_t PWMBufferBody0Body1[LED_DATA_SIZE(MAX_LEDS_PER_OUTPUT)];	// One uint32_t value for both PWM channels of same slice, represents one WS2812 bit each

// volatile uint8_t currentAnimation = BOOT_ANIMATION;
volatile bool animationLocked = false;
volatile bool changeBrightness = false, resetBrightness = false;
volatile uint8_t brightness = INITIAL_BRIGHTNESS;
int16_t brightnessAdjustment = 0;
uint8_t animationCount = 0, lastAnimation, lastLightInterval;
uint32_t lastAnimationChange, lastBrightnessChange;
uint32_t lastBatteryUpdate = 0;
FIL filAnimation;	// .fur file
FIL filConfig;
int PWMDMAChFaceCheek, PWMDMAChBody0Body1;	// DMA channel numbers
volatile bool tickFlag = false;
uint16_t animationTimer = 0;
uint16_t random_timer=0;
volatile uint16_t rxTimer = 0;	// Used for UART RX timeout
volatile uint8_t rxCounter = 0;
volatile uint8_t rxBuffer[8];

bool cardOK = false;
bool remoteOK = false;

// 2 bytes @ 31250bps = 2 * (8 + 2) / 31250 = 640us
// At 100Hz refresh (10ms), this leaves 9.36ms for the reset timeout to occur

void UARTTXIRQHandler() {
	rxTimer = 0;

    while (uart_is_readable(uart0)) {
        rxBuffer[rxCounter & 7] = uart_getc(uart0);	// This acknlowdges the RX IRQ

		// DEBUG
        if (uart_is_writable(uart0)) {
            uart_putc(uart0, 0x55);
        }

        rxCounter++;
    }
}

bool tickTimerCallback(__unused struct repeating_timer *t) {
	tickFlag = true;
	return true;
}

int configurePWMDMACh(uint PWMSliceNum, uint32_t * buffer, uint32_t dataSize) {
	int channel = dma_claim_unused_channel(true);
	dma_channel_config PWMDMAChannelConfig = dma_channel_get_default_config(channel);
	channel_config_set_transfer_data_size(&PWMDMAChannelConfig, DMA_SIZE_32);		// PWM register size
	channel_config_set_read_increment(&PWMDMAChannelConfig, true);					// Read increment from buffer
	channel_config_set_write_increment(&PWMDMAChannelConfig, false);				// Always write to the same PWM register address
	channel_config_set_dreq(&PWMDMAChannelConfig, DREQ_PWM_WRAP0 + PWMSliceNum);	// Set DREQ to PWM wrap event (reached top value)

	dma_channel_configure(
		channel,
		&PWMDMAChannelConfig,
		&pwm_hw->slice[PWMSliceNum].cc,	// Write to PWM counter compare
		buffer, 			// Read from buffer
		dataSize,
		true 				// Start now
	);

	return channel;
}

// Serial console buffer
volatile uint32_t buf_i = 0;
volatile char buf[256];

void received_char_callback(void* param) {
    int key = getchar_timeout_us(0);
	if (key == 13) {
		// CR
		buf[buf_i] = 0;
		buf_i = 0;
		long v = strtol((char*)buf, NULL, 10);
		printf("Result %u\n", v);
		updateGammaCorrection(v);
	} else {
		if (buf_i < 255 - 1) {
			buf[buf_i] = key;
			buf_i++;
		}
	}
	//printf("Keypress %u\n", key);
}

int main(void) {
	uint32_t c;
	uint32_t debugTest = stdio_init_all();
	struct repeating_timer tickTimer;
	char strBuffer[31] = { 0 };	// For OSD prints
    FRESULT fr;
    FATFS fs;
    //char filename[] = "file.fur";

	stdio_set_chars_available_callback(received_char_callback, NULL);

	// With FREF = 12MHz (Xtal osc), REFDIV = 1, FBDIV = 100: FOUTVCO = 12 / 1 * 100 = 1200
	// With POSTDIV1 = 6, POSTDIV2 = 4: FOUTPOSTDIV = 1200 / 6 / 4 = 50MHz
	set_sys_clock_pll(1200000000, 6, 4);

	memset(PWMBufferFaceCheek, 0, sizeof(PWMBufferFaceCheek));
	memset(PWMBufferBody0Body1, 0, sizeof(PWMBufferBody0Body1));

	// Init IOs
	for (c = 0; c < (sizeof(iodefs) / sizeof(iodefs[0])); c++) {
		uint32_t n = iodefs[c].number;
		gpio_set_dir(n, iodefs[c].direction);
		gpio_set_function(n, iodefs[c].function);
    	gpio_set_pulls(n, iodefs[c].pulls_state & 1, iodefs[c].pulls_state & 2);
    	gpio_put(n, iodefs[c].pulls_state & 4);
	}
	
	// Init SPI0 for MAX7456
    reset_block(RESETS_RESET_SPI0_BITS);
    unreset_block(RESETS_RESET_SPI0_BITS);
	spi_set_baudrate(spi0, 5 * 1000 * 1000);	// 50M / 10 = 5MHz, MAX7456 supports up to 10MHz
	spi_set_format(spi0, 16, SPI_CPOL_0, SPI_CPHA_0, SPI_MSB_FIRST);
    hw_set_bits(&spi_get_hw(spi0)->dmacr, SPI_SSPDMACR_TXDMAE_BITS | SPI_SSPDMACR_RXDMAE_BITS);
    hw_set_bits(&spi_get_hw(spi0)->cr1, SPI_SSPCR1_SSE_BITS);

	adc_init();
	init_osd();

	// Init remote UART
    uart_init(uart0, 31250);
    uart_set_hw_flow(uart0, false, false);
    uart_set_format(uart0, 8, 1, UART_PARITY_NONE);
    uart_set_fifo_enabled(uart0, false);
    irq_set_exclusive_handler(UART0_IRQ, UARTTXIRQHandler);
    irq_set_enabled(UART0_IRQ, true);
    uart_set_irq_enables(uart0, true, false);	// Enable RX IRQ
    uart_putc_raw(uart0, 'A');

	busy_wait_ms(1000);	// To let Teraterm reconnect to USB VCP

    // Initialize SD card
    fr = f_mount(&fs, "", 1);
    if (FR_OK != fr) {
        printDebug("f_mount failed: %s (%d)\n", FRESULT_str(fr), fr);
		cardOK = false;
    } else
		cardOK = true;
	
	animationInit();
	initialiseAutoBrightness();
	updateGammaCorrection(brightness);

    uint PWMSliceNumFaceCheek = pwm_gpio_to_slice_num(12);
    uint PWMSliceBody0Body1 = pwm_gpio_to_slice_num(14);

	PWMDMAChFaceCheek = configurePWMDMACh(PWMSliceNumFaceCheek, PWMBufferFaceCheek, LED_DATA_SIZE(FACE_LED_STRIP_LENGTH));	// TODO: This must be the highest of FACE_LED_STRIP_LENGTH and CHEEK_LED_STRIP_LENGTH
	PWMDMAChBody0Body1 = configurePWMDMACh(PWMSliceBody0Body1, PWMBufferBody0Body1, LED_DATA_SIZE(BODY1_LED_STRIP_LENGTH));	// TODO: This must be the highest of BODY0_LED_STRIP_LENGTH and BODY1_LED_STRIP_LENGTH

    pwm_config PWMConfig = pwm_get_default_config();
    //pwm_config_set_clkdiv(&PWMConfig, 6.f);	// 50M / 6 = 8.33MHz timer tick
    //pwm_config_set_wrap(&PWMConfig, 9);		// 8.33M / (9 + 1) = 833.3kHz = 1.2us period (120ns resolution)
    pwm_config_set_clkdiv(&PWMConfig, 2.f);		// 50M / 2 = 25MHz timer tick
    pwm_config_set_wrap(&PWMConfig, 29);		// 25M / (29 + 1) = 833.3kHz = 1.2us period (40ns resolution)
    pwm_init(PWMSliceNumFaceCheek, &PWMConfig, true);
    pwm_init(PWMDMAChBody0Body1, &PWMConfig, true);

	add_repeating_timer_ms(-1, tickTimerCallback, NULL, &tickTimer);	// 1kHz tick

	uint16_t LEDBlinkTimer = 0;
	uint16_t OSDUpdateTimer = 0;
	uint16_t randomAnimationTimer = 0;
	uint16_t ADCReadTimer = 0;
	bool LEDState = false;
	
	uint32_t ADCAccBattV = 0;
	uint32_t ADCAccCurrent = 0;
	uint32_t ADCAccBrightness = 0;
	uint8_t ADCAccCounter = 0;
	uint16_t ADCAvgBattV;
	uint16_t ADCAvgCurrent;
	uint16_t ADCAvgBrightness;
	uint8_t lastRemoteData[2] = { 0, 0 };

	uint32_t msSinceBoot = 0;
	uint8_t seconds = 0;
	uint8_t minutes = 0;
	uint8_t hours = 0;

	bool random_played = false;
	bool random_anim_flag = false;
	// DEBUG
	/*colorBufferCheek[0].rawlong = 0x330000;
	colorBufferCheek[1].rawlong = 0x003300;
	colorBufferCheek[2].rawlong = 0x000033;*/
	for (c = 0; c < CHEEK_LED_STRIP_LENGTH; c++) {
		colorBufferCheek[c].rawlong = COLOR_CHEEK;
	}
	for (c = 0; c < BODY0_LED_STRIP_LENGTH; c++) {
		colorBufferBody0[c].rawlong = COLOR_BODY0;
	}
	for (c = 0; c < BODY1_LED_STRIP_LENGTH; c++) {
		colorBufferBody1[c].rawlong = COLOR_BODY1;
	}
	refreshLEDs();
	startAnimation(5);	// Startup animation
	
	while(1) {

		if (tickFlag) {
			tickFlag = false;

			if (rxTimer >= 5) {
				// 5ms with no byte received, reset buffer
				rxCounter = 0;
				if (rxTimer >= 1000) {
					// No remote data since 1s :(
					remoteOK = false;
				} else
					rxTimer++;
			} else
				rxTimer++;
			
			if (rxCounter == 3) {
				if (rxBuffer[0] == 0xAC) {
					remoteOK = true;
					rxCounter = 0;
					lastRemoteData[0] = rxBuffer[1];
					lastRemoteData[1] = rxBuffer[2];
				}
			}

			// Blink LED0 at 5Hz
			if (LEDBlinkTimer >= 100) {
				LEDBlinkTimer = 0;
				gpio_put(2, LEDState);
				LEDState = !LEDState;
			} else
				LEDBlinkTimer++;

			// Read ADCs at 100Hz, produce average values at 10Hz
			if (ADCReadTimer >= 10) {
				ADCReadTimer = 0;
				// 3.3VRef 12-bit, 805.66uV/step
				adc_select_input(0);		// Battery voltage
				ADCAccBattV += adc_read();
				adc_select_input(1);		// Current
				ADCAccCurrent += adc_read();
				adc_select_input(2);		// Brightness
				ADCAccBrightness += adc_read();

				if (ADCAccCounter == ADC_AVG_COUNT - 1) {
					// Compute averages, clear accumulators
					ADCAccCounter = 0;
					ADCAvgBattV = ADCAccBattV / ADC_AVG_COUNT;
					ADCAvgCurrent = ADCAccCurrent / ADC_AVG_COUNT;
					ADCAvgBrightness = ADCAccBrightness / ADC_AVG_COUNT;
					ADCAccBattV = 0;
					ADCAccCurrent = 0;
					ADCAccBrightness = 0;
					checkBrightness(ADCAvgBrightness);
					changeBrightness = true;
				} else
					ADCAccCounter++;
			} else
				ADCReadTimer++;
			
			// Update OSD every 0.5s
			if (OSDUpdateTimer >= 500) {
				OSDUpdateTimer = 0;

				if (!cardOK) {
					// Reinitialize SD card if needed, this doesn't work well in practice, hot-plugging the SD card messes things up and requires a full reset
					if (f_mount(&fs, "", 1) == FR_OK)
						cardOK = true;
				}
				//printf("MAX7456_VM0: %02X\n", busRead(MAX7456_VM0));
				// osd_print(2, 1, "DEBUG MODE", 1);

				// // 10k/1k voltage divider
				uint32_t result = (ADCAvgBattV * 9075) >> 10;	// * 11 * 3.3 * 1000 / 4096: mV (22.10)
				sprintf(strBuffer, "%2u.%03uV", result / 1000, result % 1000);
				osd_print(1, MAX7456_PAL_ROWS-2, strBuffer, 0);

				// // Vo = IS RS RL / 5k = IS * 0.25 * 14300 / 5000 = IS * 0.715
				// // IS = Vo / (0.25 * 14300 / 5000) = Vo / 0.715 = Vo * 1.399
				// // Pico ADC precision is crap, low current won't be accurately measured (60mA real shows 130mA)
				// result = (ADCAvgCurrent * 1154) >> 10;	// * 1.399 * 3.3 * 1000 / 4096: mA (22.10)
				// sprintf(strBuffer, "CURNT:%04u (%1u.%03uA)", ADCAvgCurrent, result / 1000, result % 1000);
				// osd_print(2, 3, strBuffer, 0);
				
				// result = ADCAvgBrightness;
				// sprintf(strBuffer, "BRGHT:%04u", ADCAvgBrightness);
				// osd_print(2, 4, strBuffer, 0);

				// sprintf(strBuffer, "REMOTE:%s", remoteOK ? "OK  " : "FAIL");
				// osd_print(2, 5, strBuffer, 0);
				// unsigned char * ptr = &strBuffer[0];
				// // Binary display
				// for (uint32_t i = 0; i < 2; i++) {
				// 	for (uint32_t j = 0; j < 8; j++) {
				// 		*(ptr++) = ('0' + ((lastRemoteData[i] << j) & 0x80));
				// 	}
				// 	*(ptr++) = ' ';
				// }
				// *(ptr++) = 0;
				// osd_print(9, 6, strBuffer, 0);

				// sprintf(strBuffer, "CARD:%s", cardOK ? "OK  " : "FAIL");
				// osd_print(2, 7, strBuffer, 0);

				osd_print(1, MAX7456_PAL_ROWS-3, ANIMATION_NAME[animationCurrentNumber], 0);
				msSinceBoot = to_ms_since_boot(get_absolute_time());
				seconds = (msSinceBoot / 1000) % 60;
				minutes = (msSinceBoot / (1000*60)) % 60;
				hours = (msSinceBoot / (1000*60*60)) % 60;
				sprintf(strBuffer, "%d:%d:%d",hours,minutes,seconds);
				osd_print(20, MAX7456_PAL_ROWS-2, strBuffer, 0);

				sprintf(strBuffer, "remote:%d", lastRemoteData[0]);
				osd_print(1, MAX7456_PAL_ROWS-4, strBuffer,0);
			} else
				OSDUpdateTimer++;

			// lastAnimation = currentAnimation;
			// if (lastAnimation == currentAnimation) {
			// 	startAnimation(1);//currentAnimation = DEFAULT_ANIMATION;

			// 	if (random_timer - lastAnimationChange > RANDOM_ANIMATION_PERIOD) {
			// 		switch (rand() % 12) {
			// 			case 8:
			// 			case 9:
			// 				startAnimation(2);//currentAnimation = RANDOM_ANIMATION_1;
			// 				break;

			// 			case 10:
			// 				startAnimation(3);//currentAnimation = RANDOM_ANIMATION_2;
			// 				break;

			// 			case 11:
			// 				startAnimation(4);//currentAnimation = RANDOM_ANIMATION_3;
			// 				break;
			// 		}

			// 	} else{
			// 		random_timer++;
			// 	}
			// }
			if (randomAnimationTimer >= RANDOM_ANIMATION_PERIOD) {
				randomAnimationTimer = 0;
				random_anim_flag = true;
			} else {
				randomAnimationTimer++;
			}

			if (animationFrame >= animationFrameCount) {
				startAnimation(1);
				if (lastRemoteData[0] & 1) {
					startAnimation(6);
				} else if(random_anim_flag) {
					random_anim_flag = false;
					// randomAnimationTimer = 0;
					switch (rand() % 4)
					{
					case 0:
						startAnimation(2);
						break;
					case 1:
						startAnimation(3);
						break;
					case 2:
						startAnimation(4);
						break;
					}
				}
			}

			if (animationTimer >= animationDeltaMs) {
				animationTimer = 0;
				updateAnimation();
			} else
				animationTimer++;
		}
	}
}
/*
	if (!hardwareInit()) {
		LOG_E(SYSTEM, "Harware initialisation failed");
		return 1;
	}

	if (!animationInit()) {
		LOG_E(SYSTEM, "Animation initialisation failed");
		return 1;
	}

	initialiseAutoBrightness();
	LOG_E(SYSTEM, "Brightness initialised to %d", brightness);
	updateGammaCorrection(brightness);

	srand((unsigned int) micros());

	updateOSD(currentAnimation);

	// TODO: Use hw timer + IRQ
	while (true) {
		lastAnimation = currentAnimation;
		drawAnimation(currentAnimation);

		// animation can get changed in serialRxCallback
		if (lastAnimation == currentAnimation) {
			currentAnimation = DEFAULT_ANIMATION;

			if (millis() - lastAnimationChange > RANDOM_ANIMATION_PERIOD) {
				switch (rand() % 12) {
					case 8:
					case 9:
						currentAnimation = RANDOM_ANIMATION_1;
						break;

					case 10:
						currentAnimation = RANDOM_ANIMATION_2;
						break;

					case 11:
						currentAnimation = RANDOM_ANIMATION_3;
						break;
				}
				lastAnimationChange = millis();
			}
		}
	}*/
// }

/*void afatfs_ftellSync(afatfsFilePtr_t file, uint32_t *position) {
	while(!afatfs_ftell(file, position))
			afatfs_poll();
}*/
