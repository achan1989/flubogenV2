// Protobrain V2 for RP2040

// OSD chip might not work if powered by long/shitty USB cable, requires 5V
// On startup all GPIOs are in hi-z with a pull-down

// The WS2812 outputs are generated by the PWM peripherals (the duty cycle codes the bits) all timed to run with a 1.2us period at 120ns resolution
// PWM wrap IRQ is too slow to properly update the duty cycle value, causes bit repeats
// Instead DMA is used (DREQ on PWM wrap) to load the values from a duty cycle buffer
// The buffer has a last value set to 0 to force the output low once the buffer has been sent out (WS2812 reset period)
// FACE:     GPIO12    PWM6A    PWMBufferFaceCheek
// CHEEK:    GPIO13    PWM6B
// BODY0:    GPIO14    PWM7A    PWMBufferBody0Body1
// BODY1:    GPIO15    PWM7B
// Each PWM slice has two channels (A and B). Warning: register names use "CHx" 0 to 7 to actually names slices, which sucks.
// The counter compare (duty cycle) registers group both channels so they can only be updated at the same time, which also sucks. The pwm_set_chan_level() gets around that with a read-modify-write to only update part of the register.
// DMA can't do that however, so the DMA buffer must be made of uint32 containing two uint16, one for each channel of the slice, like the register expects.

// SD card used in SDIO mode, uses PIO0

// TODO: Current sense, auto brightness scale down if above max current
// TOOD: Interactive console to set values, save/load to txt file

// NOTE: The old MAX7456 driver assumes that the chip was loaded with a modified charset to match the standard ASCII table,
// this won't work with a brand new MAX7456.

// ADC values for automatic brightness adjustment (GL5528 photoresistor + 10k pulldown)

#include <stdint.h>

#include <hardware/clocks.h>
#include <pico/stdlib.h>
#include <pico/time.h>

#include "ws2812b/ws2812b.h"

static ws2812b_face_buffer_t face_buffer;

static void fill_face_buf(wsb2812b_led_value_t value);

int main(void) {
    hard_assert(stdio_init_all());

    ws2812b_init();
    sleep_ms(50);

    wsb2812b_led_value_t red = {.r = 125, .g = 0, .b = 0};
    wsb2812b_led_value_t green = {.r = 0, .g = 74, .b = 0};
    wsb2812b_led_value_t blue = {.r = 0, .g = 0, .b = 255};
    wsb2812b_led_value_t white = {.r = 42, .g = 25, .b = 85};

    // Loop: r g b white
    while (1)
    {
        fill_face_buf(red);
        ws2812b_face_send_buffer(&face_buffer);
        sleep_ms(1000);

        fill_face_buf(green);
        ws2812b_face_send_buffer(&face_buffer);
        sleep_ms(1000);

        fill_face_buf(blue);
        ws2812b_face_send_buffer(&face_buffer);
        sleep_ms(1000);

        fill_face_buf(white);
        ws2812b_face_send_buffer(&face_buffer);
        sleep_ms(1000);
    }
}

static void fill_face_buf(wsb2812b_led_value_t value)
{
    for (size_t i = 0; i < WS2812B_NUM_LEDS_FACE; i++)
    {
        face_buffer.values[i] = value;
    }
}
