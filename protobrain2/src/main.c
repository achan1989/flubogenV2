// Protobrain V2 for RP2040

// OSD chip might not work if powered by long/shitty USB cable, requires 5V
// On startup all GPIOs are in hi-z with a pull-down

// The WS2812 outputs are generated by the PWM peripherals (the duty cycle codes the bits) all timed to run with a 1.2us period at 120ns resolution
// PWM wrap IRQ is too slow to properly update the duty cycle value, causes bit repeats
// Instead DMA is used (DREQ on PWM wrap) to load the values from a duty cycle buffer
// The buffer has a last value set to 0 to force the output low once the buffer has been sent out (WS2812 reset period)
// FACE:     GPIO12    PWM6A    PWMBufferFaceCheek
// CHEEK:    GPIO13    PWM6B
// BODY0:    GPIO14    PWM7A    PWMBufferBody0Body1
// BODY1:    GPIO15    PWM7B
// Each PWM slice has two channels (A and B). Warning: register names use "CHx" 0 to 7 to actually names slices, which sucks.
// The counter compare (duty cycle) registers group both channels so they can only be updated at the same time, which also sucks. The pwm_set_chan_level() gets around that with a read-modify-write to only update part of the register.
// DMA can't do that however, so the DMA buffer must be made of uint32 containing two uint16, one for each channel of the slice, like the register expects.

// SD card used in SDIO mode, uses PIO0

// TODO: Current sense, auto brightness scale down if above max current
// TOOD: Interactive console to set values, save/load to txt file

// NOTE: The old MAX7456 driver assumes that the chip was loaded with a modified charset to match the standard ASCII table,
// this won't work with a brand new MAX7456.

// ADC values for automatic brightness adjustment (GL5528 photoresistor + 10k pulldown)

#include <assert.h>
#include <stdint.h>
#include <stdlib.h>

#include "main.h"
#include "gpio.h"
#include "pico/stdlib.h"
#include "leds.h"
#include "pico/time.h"

int main(void) {
    hard_assert(stdio_init_all());

    // With FREF = 12MHz (Xtal osc), REFDIV = 1, FBDIV = 100: FOUTVCO = 12 / 1 * 100 = 1200
    // With POSTDIV1 = 6, POSTDIV2 = 4: FOUTPOSTDIV = 1200 / 6 / 4 = 50MHz
    set_sys_clock_pll(1200000000, 6, 4);

    // Init IOs
    for (int c = 0; c < (sizeof(iodefs) / sizeof(iodefs[0])); c++) {
        uint32_t n = iodefs[c].number;
        gpio_set_dir(n, iodefs[c].direction);
        gpio_set_function(n, iodefs[c].function);
        gpio_set_pulls(n, iodefs[c].pulls_state & 1, iodefs[c].pulls_state & 2);
        gpio_put(n, iodefs[c].pulls_state & 4);
    }
}
